//
//  HomeViewController.swift
//  Noty
//
//  Created by Youssef Jdidi on 12/2/2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//
//  This template is meant to work with Swinject.

import UIKit
import MessageUI

protocol HomeViewControllerProtocol: class, UIViewControllerRouting {
    func set(interactor: HomeInteractorProtocol)
    func set(router: HomeRouterProtocol)
    func set(alertPresenter: AlertPresenterProtocol)
    func set(toastManager: ToastManagerProtocol)

    func display(error: Error)
    func displayPermissionError(error: HomeModels.PermissionError)
    func displayTranscriptedText(text: String)
    func displayRecordingState(state: HomeModels.RecordState)
    func displayCurrentAmplitude(with amplitude: Double)
    func displayActionSheet(actionSheet: UIAlertController)
    func display(choiceActionSheet: UIAlertController)
    func displaySpinner()
    func displaySaveResult(save result: Result<Storable?, Error>)
    func displayRoutingToTitle()
}

class HomeViewController: UIViewController, HomeViewControllerProtocol {

    // MARK: DI
    var interactor: HomeInteractorProtocol?
    var router: HomeRouterProtocol?
    var alertPresenter: AlertPresenterProtocol?
    var toastManager: ToastManagerProtocol?

    func set(interactor: HomeInteractorProtocol) {
        self.interactor = interactor
    }

    func set(router: HomeRouterProtocol) {
        self.router = router
    }

    func set(alertPresenter: AlertPresenterProtocol) {
        self.alertPresenter = alertPresenter
    }

    func set(toastManager: ToastManagerProtocol) {
        self.toastManager = toastManager
    }
    
    // MARK: Outlets
    @IBOutlet weak var textMemoView: VTextView! {
        didSet {
            textMemoView.isEditable = true
            textMemoView.isSelectable = true
            textMemoView.showsVerticalScrollIndicator = false
            textMemoView.showsHorizontalScrollIndicator = false
            textMemoView.bounces = false
            textMemoView.font = UIFont.systemFont(ofSize: 19)
        }
    }
    @IBOutlet weak var recordButton: AppButton! {
        didSet {
            recordButton.addTarget(self, action: #selector(handleRecordButtonClicked), for: .touchUpInside)
        }
    }
    @IBOutlet weak var recordingStateLabel: UILabel! {
        didSet {
            recordingStateLabel.alpha = 0
        }
    }
    @IBOutlet weak var amplitudeConstraint: NSLayoutConstraint!
    @IBOutlet weak var sendButton: AppButton! {
        didSet {
            sendButton.addTarget(self, action: #selector(sendButtonClicked), for: .touchUpInside)
        }
    }
    @IBOutlet weak var clearButton: AppButton! {
        didSet {
            clearButton.addTarget(self, action: #selector(clearRecording), for: .touchUpInside)
        }
    }
    
    // MARK: Properties
    private var timer: Timer?
    private var currentAmplitude: Double?

    // MARK: Lifecycle
    override func viewDidLoad() {
        super.viewDidLoad()
    }

    #warning("Check if text is empty if so display an alert to discard memo and set AudioKit to nil")
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        interactor?.handleViewWillDisappear()
    }
}

// MARK: Methods
extension HomeViewController {

    func display(error: Error) {}

    func displayPermissionError(error: HomeModels.PermissionError) {
        switch error {
        case .audio: alertPresenter?.presentPermissionAlert(with: .audio)
        case .speech: alertPresenter?.presentPermissionAlert(with: .speech)
        default: break
        }
    }

    func displayTranscriptedText(text: String) {
        UIView.animate(withDuration: 0.3) { [weak self] in
            guard let self = self else { return }
            self.textMemoView.textColor = .black
            self.textMemoView.text = text
            self.textMemoView.scrollRangeToVisible(
                NSRange(location: self.textMemoView.text.count - 1,
                        length: 0))
        }
    }

    func displayRecordingState(state: HomeModels.RecordState) {
        switch state {
        case .isRecoding: handleStartingRecording()
        case .isPaused: handlePauseRecording()
        case .isCleared: handleClearRecording()
        }
    }

    func displayCurrentAmplitude(with amplitude: Double) {
        self.currentAmplitude = amplitude
    }

    func displayActionSheet(actionSheet: UIAlertController) {
        addMailComposer(emailActionSheet: actionSheet)
        present(actionSheet, animated: true, completion: nil)
    }

    func display(choiceActionSheet: UIAlertController) {
        present(choiceActionSheet, animated: true, completion: nil)
    }

    func displaySpinner() {
        showSpinner()
    }

    func displaySaveResult(save result: Result<Storable?, Error>) {
        hideSpinner()
        switch result {
        case .success:
            toastManager?.showToast(for: .noteSaved)
        case .failure:
            toastManager?.showToast(for: .cantSaveNote)
        }
    }

    func displayRoutingToTitle() {
        router?.route(to: .titleAlert(text: textMemoView.text))
    }
}

private extension HomeViewController {
    @objc func handleRecordButtonClicked() {
        recordButton.isSelected ? pauseRecording() : startRecording()
    }

    func pauseRecording() {
        interactor?.pauseRecording()
    }

    func startRecording() {
        interactor?.startRecording() 
    }

    @objc func clearRecording() {
        interactor?.clearRecording()
    }

    @objc func sendButtonClicked() {
        interactor?.prepareChoiceActionSheet(with: textMemoView.text)
    }

    func handleStartingRecording() {
        UIView.animate(withDuration: 0.3) { [weak self] in
            guard let self = self else { return }
            self.view.endEditing(true)
            self.recordingStateLabel.alpha = 1
            self.recordButton.isSelected = true
            self.startAmplitudeRecorder()
            self.recordingStateLabel.text = "Listening..."
            self.sendButton.isHidden = true
            self.clearButton.isHidden = true
            DispatchQueue.main.async {
                UIView.animate(withDuration: 0.4, animations: {
                    self.view.layoutIfNeeded()
                })
            }
        }
    }

    func handlePauseRecording () {
        UIView.animate(withDuration: 0.3) { [weak self] in
            guard let self = self else { return }
            self.recordingStateLabel.alpha = 1
            self.recordButton.isSelected = false
            self.stopAmplitudeRecorder()
            self.recordingStateLabel.text = "Paused"
            self.sendButton.isHidden = self.textMemoView.placeholderText == self.textMemoView.text
            self.clearButton.isHidden = self.textMemoView.placeholderText == self.textMemoView.text
            DispatchQueue.main.async {
                UIView.animate(withDuration: 0.4, animations: {
                    self.view.layoutIfNeeded()
                })
            }
        }
    }

    func handleClearRecording() {
        UIView.animate(withDuration: 0.3) { [weak self] in
            guard let self = self else { return }
            self.textMemoView.setPlaceholder()
            self.recordingStateLabel.alpha = 0
            self.recordButton.isSelected = false
            self.stopAmplitudeRecorder()
            self.sendButton.isHidden = true
            self.clearButton.isHidden = true
            DispatchQueue.main.async {
                UIView.animate(withDuration: 0.4, animations: {
                    self.view.layoutIfNeeded()
                })
            }
        }
    }

    func startAmplitudeRecorder() {
        if let timer = timer {
            timer.invalidate()
            self.timer = nil
        }

        timer = Timer(timeInterval: 0.1, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            self.interactor?.getCurrentAmplitude()
            guard let currentAmplitude = self.currentAmplitude else { return }
            Console.log(type: .message, "\(currentAmplitude)")
            self.amplitudeConstraint.constant = CGFloat(200 * currentAmplitude + 5)
            UIView.animate(withDuration: 0.1, animations: {
                self.view.layoutIfNeeded()
            })
        }
        if let timer = timer {
            RunLoop.main.add(timer, forMode: .default)
        }
    }

    func stopAmplitudeRecorder() {
        timer?.invalidate()
        timer = nil
        restoreAmplitudeView()
    }

    func restoreAmplitudeView() {
        self.amplitudeConstraint.constant = 0
        DispatchQueue.main.async {
            UIView.animate(withDuration: 0.4, animations: {
                self.view.layoutIfNeeded()
            })
        }
    }
    
    private func addMailComposer(emailActionSheet: UIAlertController) {
        if MFMailComposeViewController.canSendMail() {
        let emailAction = UIAlertAction(title: "Mail", style: .default) {[weak self] _ in
            guard let self = self else { return }
            let mailComposeViewController = self.configureMailComposer(with: self.textMemoView.text)
            self.present(mailComposeViewController, animated: true, completion: nil)
        }
            emailActionSheet.addAction(emailAction)
        }
    }

    private func configureMailComposer(with body: String) -> MFMailComposeViewController {
        let mailComposeVC = MFMailComposeViewController()
        mailComposeVC.mailComposeDelegate = self
        mailComposeVC.setMessageBody(body, isHTML: false)
        return mailComposeVC
    }
}

extension HomeViewController: MFMailComposeViewControllerDelegate {
    func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) {
        controller.dismiss(animated: true, completion: nil)
    }
}
